#include "FBXExporter.h"
#include "AnimationTimingCorrector.h"
#include <iostream>
#include <fstream>
#include <chrono>

namespace X2FBX {

// Constructor
FBXExporter::FBXExporter()
    : logger_(Logger::GetInstance())
#ifdef FBXSDK_FOUND
    , fbxManager_(nullptr)
    , fbxScene_(nullptr)
    , fbxExporter_(nullptr)
#endif
{
#ifdef FBXSDK_FOUND
    InitializeFBX();
#endif
}

// Destructor
FBXExporter::~FBXExporter() {
#ifdef FBXSDK_FOUND
    CleanupFBX();
#endif
}

#ifdef FBXSDK_FOUND
bool FBXExporter::InitializeFBX() {
    fbxManager_ = FbxManager::Create();
    if (!fbxManager_) {
        LOG_ERROR("Failed to create FBX Manager");
        return false;
    }

    FbxIOSettings* ios = FbxIOSettings::Create(fbxManager_, IOSROOT);
    fbxManager_->SetIOSettings(ios);

    fbxExporter_ = FbxExporter::Create(fbxManager_, "");
    if (!fbxExporter_) {
        LOG_ERROR("Failed to create FBX Exporter");
        return false;
    }

    LOG_INFO("FBX SDK initialized successfully");
    return true;
}

void FBXExporter::CleanupFBX() {
    if (fbxExporter_) {
        fbxExporter_->Destroy();
        fbxExporter_ = nullptr;
    }

    if (fbxScene_) {
        fbxScene_->Destroy();
        fbxScene_ = nullptr;
    }

    if (fbxManager_) {
        fbxManager_->Destroy();
        fbxManager_ = nullptr;
    }
}
#endif

// Main export function
FBXExportResult FBXExporter::ExportToFBX(const XFileData& xData, const std::string& outputPath, const FBXExportOptions& options) {
    auto startTime = std::chrono::high_resolution_clock::now();

    FBXExportResult result;
    result.outputPath = outputPath;

#ifdef FBXSDK_FOUND
    // Real FBX export when SDK is available
    result = ExportWithFBXSDK(xData, outputPath, options);
#else
    // Placeholder export when SDK is not available
    result = ExportPlaceholder(xData, outputPath, options);
#endif

    auto endTime = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
    result.exportTimeMs = static_cast<float>(duration.count());

    return result;
}

#ifdef FBXSDK_FOUND
FBXExportResult FBXExporter::ExportWithFBXSDK(const XFileData& xData, const std::string& outputPath, const FBXExportOptions& options) {
    FBXExportResult result;

    // Create scene
    fbxScene_ = FbxScene::Create(fbxManager_, "XFileScene");
    if (!fbxScene_) {
        result.errorMessage = "Failed to create FBX scene";
        return result;
    }

    // Set scene info
    FbxDocumentInfo* sceneInfo = FbxDocumentInfo::Create(fbxManager_, "SceneInfo");
    sceneInfo->mTitle = "X File Converted to FBX";
    sceneInfo->mSubject = "Converted using X2FBX Converter";
    sceneInfo->mAuthor = "X2FBX Converter";
    sceneInfo->mRevision = "1.0";
    sceneInfo->mKeywords = "DirectX X file FBX conversion";
    sceneInfo->mComment = "Converted from DirectX .x format with animation timing correction";
    fbxScene_->SetSceneInfo(sceneInfo);

    // Export mesh data
    if (!xData.meshes.empty()) {
        result.success = ExportMeshes(xData, options);
        if (!result.success) {
            result.errorMessage = "Failed to export meshes";
            return result;
        }
    }

    // Export animations if present
    if (options.exportAnimations && !xData.animations.empty()) {
        if (options.separateAnimationFiles) {
            result.success = ExportSeparateAnimations(xData, outputPath, options);
        } else {
            result.success = ExportCombinedAnimations(xData, options);
        }

        if (!result.success) {
            result.errorMessage = "Failed to export animations";
            return result;
        }
    }

    // Save the file
    result.success = SaveFBXFile(outputPath);
    if (!result.success) {
        result.errorMessage = "Failed to save FBX file";
    }

    return result;
}
#endif

FBXExportResult FBXExporter::ExportPlaceholder(const XFileData& xData, const std::string& outputPath, const FBXExportOptions& options) {
    // Suppress unused parameter warning
    (void)options;

    FBXExportResult result;

    LOG_WARNING("FBX SDK not available - creating placeholder file");

    std::ofstream file(outputPath);
    if (!file.is_open()) {
        result.errorMessage = "Cannot create output file: " + outputPath;
        return result;
    }

    file << "; FBX PLACEHOLDER FILE\n";
    file << "; Generated by X2FBX Converter\n";
    file << "; Original file contains:\n";
    file << ";   Meshes: " << xData.meshes.size() << "\n";
    file << ";   Materials: " << xData.materials.size() << "\n";
    file << ";   Animations: " << xData.animations.size() << "\n";
    file << "\n";
    file << "; To generate real FBX files, install FBX SDK and recompile\n";
    file << "; FBX SDK download: https://www.autodesk.com/developer-network/platform-technologies/fbx-sdk\n";
    file.close();

    result.success = true;
    result.verticesExported = 0;
    result.facesExported = 0;
    result.materialsExported = static_cast<int>(xData.materials.size());
    result.animationsExported = static_cast<int>(xData.animations.size());

    LOG_INFO("Placeholder FBX file created: " + outputPath);
    return result;
}

#ifdef FBXSDK_FOUND
bool FBXExporter::ExportMeshes(const XFileData& xData, const FBXExportOptions& options) {
    for (const auto& meshData : xData.meshes) {
        if (!CreateMesh(meshData, options)) {
            return false;
        }
    }
    return true;
}

bool FBXExporter::CreateMesh(const XMeshData& meshData, const FBXExportOptions& options) {
    // Create mesh node
    FbxNode* meshNode = FbxNode::Create(fbxScene_, meshData.name.c_str());
    FbxMesh* fbxMesh = FbxMesh::Create(fbxScene_, (meshData.name + "_mesh").c_str());

    // Set vertices
    fbxMesh->InitControlPoints(static_cast<int>(meshData.vertices.size()));
    FbxVector4* controlPoints = fbxMesh->GetControlPoints();

    for (size_t i = 0; i < meshData.vertices.size(); ++i) {
        const auto& vertex = meshData.vertices[i];
        if (options.convertCoordinateSystem && options.flipYZ) {
            // Convert DirectX to FBX coordinate system
            controlPoints[i] = FbxVector4(vertex.position.x, vertex.position.z, -vertex.position.y);
        } else {
            controlPoints[i] = FbxVector4(vertex.position.x, vertex.position.y, vertex.position.z);
        }
    }

    // Set faces
    for (const auto& face : meshData.faces) {
        fbxMesh->BeginPolygon();
        for (int vertexIndex : face.vertexIndices) {
            fbxMesh->AddPolygon(vertexIndex);
        }
        fbxMesh->EndPolygon();
    }

    // Create skeleton if bones exist
    if (!meshData.bones.empty() && options.exportAnimations) {
        CreateSkeleton(meshData);
    }

    meshNode->SetNodeAttribute(fbxMesh);
    fbxScene_->GetRootNode()->AddChild(meshNode);

    return true;
}

bool FBXExporter::CreateSkeleton(const XMeshData& meshData) {
    if (meshData.bones.empty()) {
        return false;
    }

    LOG_INFO("Creating skeleton with " + std::to_string(meshData.bones.size()) + " bones");

    // Implementation for skeleton creation would go here
    // This is a complex process involving bone nodes, clusters, etc.

    return true;
}

bool FBXExporter::SaveFBXFile(const std::string& outputPath) {
    int fileFormat = fbxManager_->GetIOPluginRegistry()->GetNativeWriterFormat();

    if (!fbxExporter_->Initialize(outputPath.c_str(), fileFormat, fbxManager_->GetIOSettings())) {
        LOG_ERROR("Failed to initialize FBX exporter for: " + outputPath);
        return false;
    }

    bool success = fbxExporter_->Export(fbxScene_);
    if (!success) {
        LOG_ERROR("Failed to export FBX file: " + outputPath);
    } else {
        LOG_INFO("FBX file exported successfully: " + outputPath);
    }

    return success;
}

bool FBXExporter::ExportSeparateAnimations(const XFileData& xData, const std::string& basePath, const FBXExportOptions& options) {
    if (!xData.IsValid()) {
        logger_.Error("Invalid XFileData provided for separate animation export");
        return false;
    }

    const auto& meshData = xData.meshData;
    if (meshData.animations.empty()) {
        logger_.Info("No animations found in the data - exporting static mesh only");

        // Export a single static mesh file
        std::string staticPath = basePath + "_static.fbx";
        FBXExportResult result = ExportStaticMesh(meshData, staticPath, options);
        return result.success;
    }

    logger_.Info("Exporting " + std::to_string(meshData.animations.size()) + " animations as separate files");

    bool allSuccess = true;
    int exportedCount = 0;

    // Export each animation as a separate file
    for (const auto& animation : meshData.animations) {
        std::string animationFileName = basePath + "_" + animation.name + ".fbx";

        // Sanitize filename - remove invalid characters
        std::string sanitizedName = animation.name;
        for (char& c : sanitizedName) {
            if (c == ' ' || c == '/' || c == '\\' || c == ':' || c == '*' || c == '?' || c == '"' || c == '<' || c == '>' || c == '|') {
                c = '_';
            }
        }
        animationFileName = basePath + "_" + sanitizedName + ".fbx";

        logger_.Info("Exporting animation: " + animation.name + " -> " + animationFileName);

        try {
            FBXExportResult result = ExportAnimatedMesh(meshData, animation, animationFileName, options);

            if (result.success) {
                exportedCount++;
                logger_.Info("Successfully exported animation: " + animation.name +
                           " (Duration: " + std::to_string(animation.GetDurationInSeconds()) + "s, " +
                           "Keyframes: " + std::to_string(animation.keyframes.size()) + ")");
            } else {
                allSuccess = false;
                logger_.Error("Failed to export animation: " + animation.name +
                           " - Error: " + result.errorMessage);
            }
        } catch (const std::exception& e) {
            allSuccess = false;
            logger_.Error("Exception while exporting animation " + animation.name + ": " + e.what());
        }
    }

    // Also export a static mesh file without animations
    if (options.exportAnimations) {
        std::string staticPath = basePath + "_static.fbx";
        logger_.Info("Exporting static mesh: " + staticPath);

        FBXExportOptions staticOptions = options;
        staticOptions.exportAnimations = false;

        FBXExportResult staticResult = ExportStaticMesh(meshData, staticPath, staticOptions);
        if (!staticResult.success) {
            logger_.Warning("Failed to export static mesh: " + staticResult.errorMessage);
        }
    }

    logger_.Info("Separate animation export completed. " +
               std::to_string(exportedCount) + "/" + std::to_string(meshData.animations.size()) +
               " animations exported successfully");

    return allSuccess;
}

bool FBXExporter::ExportCombinedAnimations(const XFileData& xData, const FBXExportOptions& options) {
    if (!xData.IsValid()) {
        logger_.Error("Invalid XFileData provided for combined animation export");
        return false;
    }

    const auto& meshData = xData.meshData;
    if (meshData.animations.empty()) {
        logger_.Warning("No animations found in the data - cannot export combined animations");
        return false;
    }

    logger_.Info("Exporting " + std::to_string(meshData.animations.size()) + " animations as combined file");

#ifdef FBXSDK_FOUND
    try {
        // Initialize FBX scene if not already done
        if (!fbxScene_) {
            if (!CreateScene("CombinedAnimations")) {
                logger_.Error("Failed to create FBX scene for combined animations");
                return false;
            }
        }

        // Create the main mesh node
        FbxNode* meshNode = FbxNode::Create(fbxScene_, "CombinedMesh");
        if (!meshNode) {
            logger_.Error("Failed to create mesh node for combined animations");
            return false;
        }

        // Create and attach the mesh
        FbxMesh* fbxMesh = CreateFBXMesh(meshData, "CombinedMesh");
        if (!fbxMesh) {
            logger_.Error("Failed to create FBX mesh for combined animations");
            return false;
        }
        meshNode->SetNodeAttribute(fbxMesh);

        // Add mesh node to scene
        fbxScene_->GetRootNode()->AddChild(meshNode);

        // Create skeleton if bones exist
        if (!meshData.bones.empty()) {
            if (!CreateSkeleton(meshData)) {
                logger_.Warning("Failed to create skeleton for combined animations");
            }

            // Apply skin weights
            if (!ApplySkinWeights(meshData, fbxMesh)) {
                logger_.Warning("Failed to apply skin weights for combined animations");
            }
        }

        // Create animation stacks for all animations
        for (const auto& animation : meshData.animations) {
            logger_.Info("Adding animation: " + animation.name +
                       " (Duration: " + std::to_string(animation.GetDurationInSeconds()) + "s)");

            if (!CreateAnimation(animation, options.animationFrameRate)) {
                logger_.Warning("Failed to create animation: " + animation.name);
            }
        }

        // Set up materials
        if (options.exportMaterials && !meshData.materials.empty()) {
            auto fbxMaterials = ConvertMaterials(meshData);
            for (size_t i = 0; i < fbxMaterials.size() && i < meshData.materials.size(); ++i) {
                if (fbxMaterials[i]) {
                    meshNode->AddMaterial(fbxMaterials[i]);
                }
            }
        }

        // Validate the scene
        if (!ValidateScene()) {
            logger_.Warning("Scene validation failed for combined animations");
        }

        logger_.Info("Combined animation export setup completed successfully");
        return true;

    } catch (const std::exception& e) {
        logger_.Error("Exception during combined animation export: " + std::string(e.what()));
        return false;
    }

#else
    // Fallback when FBX SDK is not available
    logger_.Warning("FBX SDK not available - creating placeholder combined animation file");

    // Create a simple text file describing the combined animations
    std::string placeholderPath = "combined_animations_info.txt";
    std::ofstream file(placeholderPath);
    if (file.is_open()) {
        file << "Combined Animation Export Information\n";
        file << "=====================================\n\n";
        file << "Total Animations: " << meshData.animations.size() << "\n\n";

        for (const auto& animation : meshData.animations) {
            file << "Animation: " << animation.name << "\n";
            file << "  Duration: " << animation.GetDurationInSeconds() << " seconds\n";
            file << "  Keyframes: " << animation.keyframes.size() << "\n";
            file << "  Ticks per second: " << animation.ticksPerSecond << "\n";

            // List bones with keyframes
            if (!animation.boneKeyframes.empty()) {
                file << "  Animated bones:\n";
                for (const auto& boneAnim : animation.boneKeyframes) {
                    file << "    - " << boneAnim.first << " (" << boneAnim.second.size() << " keyframes)\n";
                }
            }
            file << "\n";
        }

        file << "Mesh Information:\n";
        file << "  Vertices: " << meshData.GetVertexCount() << "\n";
        file << "  Faces: " << meshData.GetFaceCount() << "\n";
        file << "  Bones: " << meshData.GetBoneCount() << "\n";
        file << "  Materials: " << meshData.materials.size() << "\n";

        file.close();
        logger_.Info("Created placeholder combined animation info file: " + placeholderPath);
        return true;
    } else {
        logger_.Error("Failed to create placeholder combined animation file");
        return false;
    }
#endif
}
#endif

// Implementation of missing methods

FBXExportResult FBXExporter::ExportStaticMesh(const XMeshData& meshData,
                                              const std::string& outputPath,
                                              const FBXExportOptions& options) {
    FBXExportResult result;
    result.outputPath = outputPath;

#ifdef FBXSDK_FOUND
    try {
        // Create a new scene for this export
        if (!CreateScene("StaticMesh")) {
            result.errorMessage = "Failed to create FBX scene";
            return result;
        }

        // Create the mesh
        FbxMesh* fbxMesh = CreateFBXMesh(meshData, "StaticMesh");
        if (!fbxMesh) {
            result.errorMessage = "Failed to create FBX mesh";
            return result;
        }

        // Create mesh node and add to scene
        FbxNode* meshNode = FbxNode::Create(fbxScene_, "StaticMeshNode");
        meshNode->SetNodeAttribute(fbxMesh);
        fbxScene_->GetRootNode()->AddChild(meshNode);

        // Add materials if requested
        if (options.exportMaterials && !meshData.materials.empty()) {
            auto fbxMaterials = ConvertMaterials(meshData);
            for (auto* material : fbxMaterials) {
                if (material) {
                    meshNode->AddMaterial(material);
                }
            }
            result.materialsExported = static_cast<int>(fbxMaterials.size());
        }

        // Save the file
        if (SaveFBXFile(outputPath)) {
            result.success = true;
            result.verticesExported = static_cast<int>(meshData.vertices.size());
            result.facesExported = static_cast<int>(meshData.faces.size());
        } else {
            result.errorMessage = "Failed to save FBX file";
        }

    } catch (const std::exception& e) {
        result.errorMessage = "Exception during static mesh export: " + std::string(e.what());
    }
#else
    // Placeholder export - create empty XFileData for static mesh
    XFileData emptyData;
    emptyData.meshData.vertices.resize(meshData.vertices.size());
    emptyData.meshData.faces.resize(meshData.faces.size());
    emptyData.materials = meshData.materials;
    result = ExportPlaceholder(emptyData, outputPath, options);
#endif

    return result;
}

FBXExportResult FBXExporter::ExportAnimatedMesh(const XMeshData& meshData,
                                               const XAnimationSet& animation,
                                               const std::string& outputPath,
                                               const FBXExportOptions& options) {
    FBXExportResult result;
    result.outputPath = outputPath;

#ifdef FBXSDK_FOUND
    try {
        // Create a new scene for this export
        if (!CreateScene("AnimatedMesh")) {
            result.errorMessage = "Failed to create FBX scene";
            return result;
        }

        // Create the mesh
        FbxMesh* fbxMesh = CreateFBXMesh(meshData, "AnimatedMesh");
        if (!fbxMesh) {
            result.errorMessage = "Failed to create FBX mesh";
            return result;
        }

        // Create mesh node and add to scene
        FbxNode* meshNode = FbxNode::Create(fbxScene_, "AnimatedMeshNode");
        meshNode->SetNodeAttribute(fbxMesh);
        fbxScene_->GetRootNode()->AddChild(meshNode);

        // Create skeleton if bones exist
        if (!meshData.bones.empty()) {
            CreateSkeleton(meshData);
            ApplySkinWeights(meshData, fbxMesh);
        }

        // Create animation
        if (CreateAnimation(animation, options.animationFrameRate)) {
            result.animationsExported = 1;
        }

        // Add materials if requested
        if (options.exportMaterials && !meshData.materials.empty()) {
            auto fbxMaterials = ConvertMaterials(meshData);
            for (auto* material : fbxMaterials) {
                if (material) {
                    meshNode->AddMaterial(material);
                }
            }
            result.materialsExported = static_cast<int>(fbxMaterials.size());
        }

        // Save the file
        if (SaveFBXFile(outputPath)) {
            result.success = true;
            result.verticesExported = static_cast<int>(meshData.vertices.size());
            result.facesExported = static_cast<int>(meshData.faces.size());
            result.bonesExported = static_cast<int>(meshData.bones.size());
        } else {
            result.errorMessage = "Failed to save FBX file";
        }

    } catch (const std::exception& e) {
        result.errorMessage = "Exception during animated mesh export: " + std::string(e.what());
    }
#else
    // Placeholder export - create empty XFileData for animated mesh
    XFileData emptyData;
    emptyData.meshData.vertices.resize(meshData.vertices.size());
    emptyData.meshData.faces.resize(meshData.faces.size());
    emptyData.materials = meshData.materials;
    emptyData.meshData.animations.push_back(animation);
    result = ExportPlaceholder(emptyData, outputPath, options);
#endif

    return result;
}

#ifdef FBXSDK_FOUND
bool FBXExporter::CreateScene(const std::string& sceneName) {
    if (fbxScene_) {
        fbxScene_->Destroy();
    }

    fbxScene_ = FbxScene::Create(fbxManager_, sceneName.c_str());
    if (!fbxScene_) {
        LOG_ERROR("Failed to create FBX scene: " + sceneName);
        return false;
    }

    // Set scene info
    FbxDocumentInfo* sceneInfo = FbxDocumentInfo::Create(fbxManager_, "SceneInfo");
    sceneInfo->mTitle = ("X File Scene: " + sceneName).c_str();
    sceneInfo->mSubject = "Converted using X2FBX Converter";
    sceneInfo->mAuthor = "X2FBX Converter";
    sceneInfo->mRevision = "1.0";
    sceneInfo->mKeywords = "DirectX X file FBX conversion";
    sceneInfo->mComment = "Converted from DirectX .x format with animation timing correction";
    fbxScene_->SetSceneInfo(sceneInfo);

    // Clear bone node tracking
    boneNodes_.clear();
    boneNodeMap_.clear();

    LOG_INFO("Created FBX scene: " + sceneName);
    return true;
}

FbxMesh* FBXExporter::CreateFBXMesh(const XMeshData& meshData, const std::string& meshName) {
    if (!fbxScene_) {
        LOG_ERROR("No FBX scene available for mesh creation");
        return nullptr;
    }

    // Create mesh
    FbxMesh* fbxMesh = FbxMesh::Create(fbxScene_, meshName.c_str());
    if (!fbxMesh) {
        LOG_ERROR("Failed to create FBX mesh: " + meshName);
        return nullptr;
    }

    // Set vertices
    fbxMesh->InitControlPoints(static_cast<int>(meshData.vertices.size()));
    FbxVector4* controlPoints = fbxMesh->GetControlPoints();

    for (size_t i = 0; i < meshData.vertices.size(); ++i) {
        const auto& vertex = meshData.vertices[i];
        // Convert DirectX to FBX coordinate system (flip Y and Z)
        controlPoints[i] = FbxVector4(vertex.position.x, vertex.position.z, -vertex.position.y);
    }

    // Set faces
    for (const auto& face : meshData.faces) {
        fbxMesh->BeginPolygon();
        for (int vertexIndex : face.vertexIndices) {
            fbxMesh->AddPolygon(vertexIndex);
        }
        fbxMesh->EndPolygon();
    }

    // Add normals if available
    if (!meshData.vertices.empty() && meshData.vertices[0].normal.x != 0.0f ||
        meshData.vertices[0].normal.y != 0.0f || meshData.vertices[0].normal.z != 0.0f) {

        FbxGeometryElementNormal* normalElement = fbxMesh->CreateElementNormal();
        normalElement->SetMappingMode(FbxGeometryElement::eByControlPoint);
        normalElement->SetReferenceMode(FbxGeometryElement::eDirect);

        for (const auto& vertex : meshData.vertices) {
            // Convert normal coordinates
            FbxVector4 normal(vertex.normal.x, vertex.normal.z, -vertex.normal.y);
            normalElement->GetDirectArray().Add(normal);
        }
    }

    // Add UVs if available
    if (!meshData.vertices.empty() && (meshData.vertices[0].texCoord.u != 0.0f ||
        meshData.vertices[0].texCoord.v != 0.0f)) {

        FbxGeometryElementUV* uvElement = fbxMesh->CreateElementUV("UVSet");
        uvElement->SetMappingMode(FbxGeometryElement::eByControlPoint);
        uvElement->SetReferenceMode(FbxGeometryElement::eDirect);

        for (const auto& vertex : meshData.vertices) {
            FbxVector2 uv(vertex.texCoord.u, 1.0 - vertex.texCoord.v); // Flip V coordinate
            uvElement->GetDirectArray().Add(uv);
        }
    }

    LOG_INFO("Created FBX mesh '" + meshName + "' with " +
             std::to_string(meshData.vertices.size()) + " vertices and " +
             std::to_string(meshData.faces.size()) + " faces");

    return fbxMesh;
}

std::vector<FbxSurfacePhong*> FBXExporter::ConvertMaterials(const XMeshData& meshData) {
    std::vector<FbxSurfacePhong*> fbxMaterials;

    for (size_t i = 0; i < meshData.materials.size(); ++i) {
        const auto& xMaterial = meshData.materials[i];

        // Create material
        std::string materialName = xMaterial.name.empty() ?
            ("Material_" + std::to_string(i)) : xMaterial.name;

        FbxSurfacePhong* fbxMaterial = FbxSurfacePhong::Create(fbxScene_, materialName.c_str());
        if (!fbxMaterial) {
            LOG_WARNING("Failed to create material: " + materialName);
            fbxMaterials.push_back(nullptr);
            continue;
        }

        // Set material properties
        fbxMaterial->Diffuse.Set(FbxDouble3(xMaterial.diffuseColor.x, xMaterial.diffuseColor.y, xMaterial.diffuseColor.z));
        fbxMaterial->Specular.Set(FbxDouble3(xMaterial.specularColor.x, xMaterial.specularColor.y, xMaterial.specularColor.z));
        fbxMaterial->Emissive.Set(FbxDouble3(xMaterial.emissiveColor.x, xMaterial.emissiveColor.y, xMaterial.emissiveColor.z));
        fbxMaterial->Shininess.Set(xMaterial.shininess);
        fbxMaterial->TransparencyFactor.Set(xMaterial.transparency);

        // Add texture if available
        if (!xMaterial.diffuseTexture.empty()) {
            FbxFileTexture* texture = FbxFileTexture::Create(fbxScene_, (materialName + "_texture").c_str());
            texture->SetFileName(xMaterial.diffuseTexture.c_str());
            texture->SetTextureUse(FbxTexture::eStandard);
            texture->SetMappingType(FbxTexture::eUV);
            texture->SetMaterialUse(FbxFileTexture::eModelMaterial);
            texture->SetSwapUV(false);
            texture->SetTranslation(0.0, 0.0);
            texture->SetScale(1.0, 1.0);
            texture->SetRotation(0.0, 0.0);

            // Connect texture to material
            fbxMaterial->Diffuse.ConnectSrcObject(texture);
        }

        fbxMaterials.push_back(fbxMaterial);
    }

    LOG_INFO("Converted " + std::to_string(fbxMaterials.size()) + " materials");
    return fbxMaterials;
}

bool FBXExporter::ApplySkinWeights(const XMeshData& meshData, FbxMesh* fbxMesh) {
    if (meshData.bones.empty() || !fbxMesh) {
        return false;
    }

    LOG_INFO("Applying skin weights for " + std::to_string(meshData.bones.size()) + " bones");

    // Create skin deformer
    FbxSkin* skin = FbxSkin::Create(fbxScene_, "Skin");
    if (!skin) {
        LOG_ERROR("Failed to create skin deformer");
        return false;
    }

    // Create clusters for each bone
    for (const auto& bone : meshData.bones) {
        FbxCluster* cluster = FbxCluster::Create(fbxScene_, (bone.name + "_cluster").c_str());
        if (!cluster) {
            LOG_WARNING("Failed to create cluster for bone: " + bone.name);
            continue;
        }

        // Find corresponding bone node
        auto it = boneNodeMap_.find(bone.name);
        if (it != boneNodeMap_.end()) {
            cluster->SetLink(it->second);
            cluster->SetLinkMode(FbxCluster::eTotalOne);

            // Add vertex weights from vertex bone data
            for (size_t vertexIndex = 0; vertexIndex < meshData.vertices.size(); ++vertexIndex) {
                const auto& vertex = meshData.vertices[vertexIndex];

                // Find if this vertex has weight for this bone
                for (size_t weightIndex = 0; weightIndex < vertex.boneIndices.size(); ++weightIndex) {
                    if (weightIndex < vertex.boneWeights.size() &&
                        vertex.boneIndices[weightIndex] == static_cast<int>(&bone - &meshData.bones[0]) &&
                        vertex.boneWeights[weightIndex] > 0.0f) {
                        cluster->AddControlPointIndex(static_cast<int>(vertexIndex), vertex.boneWeights[weightIndex]);
                    }
                }
            }

            skin->AddCluster(cluster);
        }
    }

    // Add skin to mesh
    fbxMesh->AddDeformer(skin);

    LOG_INFO("Applied skin weights successfully");
    return true;
}

bool FBXExporter::CreateAnimation(const XAnimationSet& animation, float frameRate) {
    // Suppress unused parameter warning
    (void)frameRate;

    if (!fbxScene_) {
        LOG_ERROR("No FBX scene available for animation creation");
        return false;
    }

    LOG_INFO("Creating animation: " + animation.name +
             " (Duration: " + std::to_string(animation.GetDurationInSeconds()) + "s)");

    // Create animation stack
    FbxAnimStack* animStack = FbxAnimStack::Create(fbxScene_, animation.name.c_str());
    if (!animStack) {
        LOG_ERROR("Failed to create animation stack: " + animation.name);
        return false;
    }

    // Create animation layer
    FbxAnimLayer* animLayer = FbxAnimLayer::Create(fbxScene_, (animation.name + "_layer").c_str());
    if (!animLayer) {
        LOG_ERROR("Failed to create animation layer: " + animation.name);
        return false;
    }

    animStack->AddMember(animLayer);

    // Set animation time span
    FbxTime startTime, endTime;
    startTime.SetSecondDouble(0.0);
    endTime.SetSecondDouble(animation.GetDurationInSeconds());

    FbxTimeSpan timeSpan(startTime, endTime);
    animStack->SetLocalTimeSpan(timeSpan);

    // Create keyframes for each bone
    for (const auto& boneAnim : animation.boneKeyframes) {
        auto it = boneNodeMap_.find(boneAnim.first);
        if (it == boneNodeMap_.end()) {
            LOG_WARNING("Bone not found for animation: " + boneAnim.first);
            continue;
        }

        FbxNode* boneNode = it->second;
        const auto& keyframes = boneAnim.second;

        // Create animation curves
        FbxAnimCurve* translationCurveX = boneNode->LclTranslation.GetCurve(animLayer, FBXSDK_CURVENODE_COMPONENT_X, true);
        FbxAnimCurve* translationCurveY = boneNode->LclTranslation.GetCurve(animLayer, FBXSDK_CURVENODE_COMPONENT_Y, true);
        FbxAnimCurve* translationCurveZ = boneNode->LclTranslation.GetCurve(animLayer, FBXSDK_CURVENODE_COMPONENT_Z, true);

        FbxAnimCurve* rotationCurveX = boneNode->LclRotation.GetCurve(animLayer, FBXSDK_CURVENODE_COMPONENT_X, true);
        FbxAnimCurve* rotationCurveY = boneNode->LclRotation.GetCurve(animLayer, FBXSDK_CURVENODE_COMPONENT_Y, true);
        FbxAnimCurve* rotationCurveZ = boneNode->LclRotation.GetCurve(animLayer, FBXSDK_CURVENODE_COMPONENT_Z, true);

        FbxAnimCurve* scaleCurveX = boneNode->LclScaling.GetCurve(animLayer, FBXSDK_CURVENODE_COMPONENT_X, true);
        FbxAnimCurve* scaleCurveY = boneNode->LclScaling.GetCurve(animLayer, FBXSDK_CURVENODE_COMPONENT_Y, true);
        FbxAnimCurve* scaleCurveZ = boneNode->LclScaling.GetCurve(animLayer, FBXSDK_CURVENODE_COMPONENT_Z, true);

        // Add keyframes
        for (const auto& keyframe : keyframes) {
            FbxTime fbxTime;
            fbxTime.SetSecondDouble(keyframe.time);

            // Translation
            if (translationCurveX && translationCurveY && translationCurveZ) {
                int keyIndex;
                keyIndex = translationCurveX->KeyAdd(fbxTime);
                translationCurveX->KeySetValue(keyIndex, static_cast<float>(keyframe.position.x));
                translationCurveX->KeySetInterpolation(keyIndex, FbxAnimCurveDef::eInterpolationLinear);

                keyIndex = translationCurveY->KeyAdd(fbxTime);
                translationCurveY->KeySetValue(keyIndex, static_cast<float>(keyframe.position.z));
                translationCurveY->KeySetInterpolation(keyIndex, FbxAnimCurveDef::eInterpolationLinear);

                keyIndex = translationCurveZ->KeyAdd(fbxTime);
                translationCurveZ->KeySetValue(keyIndex, static_cast<float>(-keyframe.position.y));
                translationCurveZ->KeySetInterpolation(keyIndex, FbxAnimCurveDef::eInterpolationLinear);
            }

            // Rotation (convert quaternion to Euler)
            if (rotationCurveX && rotationCurveY && rotationCurveZ) {
                // Simple quaternion to Euler conversion (simplified)
                FbxVector4 euler = FbxQuaternion(keyframe.rotation.x, keyframe.rotation.z,
                                               -keyframe.rotation.y, keyframe.rotation.w).DecomposeSphericalXYZ();

                int keyIndex;
                keyIndex = rotationCurveX->KeyAdd(fbxTime);
                rotationCurveX->KeySetValue(keyIndex, static_cast<float>(euler[0] * 180.0 / 3.14159));
                rotationCurveX->KeySetInterpolation(keyIndex, FbxAnimCurveDef::eInterpolationLinear);

                keyIndex = rotationCurveY->KeyAdd(fbxTime);
                rotationCurveY->KeySetValue(keyIndex, static_cast<float>(euler[1] * 180.0 / 3.14159));
                rotationCurveY->KeySetInterpolation(keyIndex, FbxAnimCurveDef::eInterpolationLinear);

                keyIndex = rotationCurveZ->KeyAdd(fbxTime);
                rotationCurveZ->KeySetValue(keyIndex, static_cast<float>(euler[2] * 180.0 / 3.14159));
                rotationCurveZ->KeySetInterpolation(keyIndex, FbxAnimCurveDef::eInterpolationLinear);
            }

            // Scaling
            if (scaleCurveX && scaleCurveY && scaleCurveZ) {
                int keyIndex;
                keyIndex = scaleCurveX->KeyAdd(fbxTime);
                scaleCurveX->KeySetValue(keyIndex, static_cast<float>(keyframe.scale.x));
                scaleCurveX->KeySetInterpolation(keyIndex, FbxAnimCurveDef::eInterpolationLinear);

                keyIndex = scaleCurveY->KeyAdd(fbxTime);
                scaleCurveY->KeySetValue(keyIndex, static_cast<float>(keyframe.scale.z));
                scaleCurveY->KeySetInterpolation(keyIndex, FbxAnimCurveDef::eInterpolationLinear);

                keyIndex = scaleCurveZ->KeyAdd(fbxTime);
                scaleCurveZ->KeySetValue(keyIndex, static_cast<float>(keyframe.scale.y));
                scaleCurveZ->KeySetInterpolation(keyIndex, FbxAnimCurveDef::eInterpolationLinear);
            }
        }
    }

    LOG_INFO("Created animation successfully: " + animation.name);
    return true;
}

bool FBXExporter::ValidateScene() const {
    if (!fbxScene_) {
        LOG_ERROR("No scene to validate");
        return false;
    }

    // Basic scene validation
    FbxNode* rootNode = fbxScene_->GetRootNode();
    if (!rootNode) {
        LOG_ERROR("Scene has no root node");
        return false;
    }

    int nodeCount = rootNode->GetChildCount();
    if (nodeCount == 0) {
        LOG_WARNING("Scene has no child nodes");
        return false;
    }

    // Validate each mesh node
    for (int i = 0; i < nodeCount; ++i) {
        FbxNode* node = rootNode->GetChild(i);
        if (node && node->GetNodeAttribute()) {
            FbxNodeAttribute::EType attributeType = node->GetNodeAttribute()->GetAttributeType();
            if (attributeType == FbxNodeAttribute::eMesh) {
                FbxMesh* mesh = static_cast<FbxMesh*>(node->GetNodeAttribute());
                if (!ValidateMesh(mesh)) {
                    LOG_WARNING("Mesh validation failed for node: " + std::string(node->GetName()));
                }
            }
        }
    }

    LOG_INFO("Scene validation completed");
    return true;
}

bool FBXExporter::ValidateMesh(FbxMesh* mesh) const {
    if (!mesh) {
        return false;
    }

    int vertexCount = mesh->GetControlPointsCount();
    int polygonCount = mesh->GetPolygonCount();

    if (vertexCount == 0) {
        LOG_WARNING("Mesh has no vertices");
        return false;
    }

    if (polygonCount == 0) {
        LOG_WARNING("Mesh has no polygons");
        return false;
    }

    // Check for valid polygon indices
    for (int i = 0; i < polygonCount; ++i) {
        int polygonSize = mesh->GetPolygonSize(i);
        if (polygonSize < 3) {
            LOG_WARNING("Mesh has invalid polygon with size < 3");
            return false;
        }

        for (int j = 0; j < polygonSize; ++j) {
            int vertexIndex = mesh->GetPolygonVertex(i, j);
            if (vertexIndex < 0 || vertexIndex >= vertexCount) {
                LOG_WARNING("Mesh has invalid vertex index: " + std::to_string(vertexIndex));
                return false;
            }
        }
    }

    return true;
}
#endif

// Static methods
bool FBXExporter::IsFBXSDKAvailable() {
#ifdef FBXSDK_FOUND
    return true;
#else
    return false;
#endif
}

std::string FBXExporter::GetFBXSDKVersion() {
#ifdef FBXSDK_FOUND
    return std::string(FBXSDK_VERSION_STRING);
#else
    return "FBX SDK not available";
#endif
}

} // namespace X2FBX
